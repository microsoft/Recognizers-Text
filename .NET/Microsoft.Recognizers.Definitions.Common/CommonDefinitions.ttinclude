<#@ assembly name="System.Core" #>
<#@ assembly name="System.IO" #>
<#@ assembly name="System.IO.FileSystem" #>
<#@ assembly name="System.Linq"#>
<#@ assembly name="System.Runtime"#>
<#@ assembly name="System.Runtime.Extensions"#>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="Microsoft.Recognizers.Definitions.Common" #>
<#
	// Read the model file 
	var path = @"..\..\" + this.DataFilename;
	var input = new StringReader(File.ReadAllText(path)); 
	var yamlParser = new YamlParser();
	var obj = yamlParser.Deserialize(input);
#>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
//
//     Generation parameters:
//     - DataFilename: <#= this.GetSafeParameterValue(this.DataFilename) #>
//     - Language: <#= this.GetSafeParameterValue(this.Language) #>
//     - ClassName: <#= this.GetSafeParameterValue(this.ClassName) #>
// </auto-generated>
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// ------------------------------------------------------------------------------

namespace Microsoft.Recognizers.Definitions<#= this.Language != null ? "." + this.Language : "" #>
{
	using System;
	using System.Collections.Generic;

	public static class <#= this.ClassName #>
	{
<#
    foreach (var node in obj)
    {
		var nodeType = node.Value.GetType();
		if (nodeType == typeof(char)) {
#>		public const char <#= node.Key #> = '<#= node.Value #>';<#
        }
		if (nodeType == typeof(string)) {
#>		public const string <#= node.Key #> = @"<#= node.Value #>";<#
        }
		if (node.Value is IList<object>) {
			var values = node.Value as IList<object>;
#>		public static readonly string[] <#= node.Key #> = { <#= string.Join(", ", values.Select(x => GetWriteable(x, "string"))) #> };<#
        }
		if (nodeType == typeof(SimpleRegex))
		{
			var value = node.Value as SimpleRegex;
#>		public const string <#= node.Key #> = @"<#= value.Definition #>";<#
		}
		if (nodeType == typeof(NestedRegex))
        {
			var value = node.Value as NestedRegex;
#>		public static readonly string <#= node.Key #> = $@"<#= value.SanitizedDefinition #>";<#
        }
		if (nodeType == typeof(ParamsRegex))
        {
			var value = node.Value as ParamsRegex;
#>		public static readonly Func<string, <#= string.Join(", ", value.Params.Select(x => "string")) #>> <#= node.Key #> = (<#= string.Join(", ", value.Params) #>) => $@"<#= value.SanitizedDefinition #>";<#
        }
		if (nodeType == typeof(Dictionary))
        {
			var value = node.Value as Dictionary;
			var keyDeclarationType = GetDeclarationType(value.Types[0]);
			var valueDeclarationType = GetDeclarationType(value.Types[1]);
#>		public static readonly Dictionary<<#= keyDeclarationType #>, <#= valueDeclarationType #>> <#= node.Key #> = new Dictionary<<#= keyDeclarationType #>, <#= valueDeclarationType #>>
		{
<#= string.Join("," + Environment.NewLine, value.Entries.Select(x => string.Format("\t\t\t{{ {0}, {1} }}", GetWriteable(x.Key, value.Types[0]), GetWriteable(x.Value, value.Types[1])))) #>
		};<#
		}
		if (nodeType == typeof(List))
        {
			var value = node.Value as List;
#>		public static readonly IList<<#= value.Types[0] #>> <#= node.Key #> = new List<<#= value.Types[0] #>>
		{
<#= string.Join("," + Environment.NewLine, value.Entries.Select(x => string.Format("\t\t\t{0}", GetWriteable(x, value.Types[0])))) #>
		};<#
		}
#>

<#
    }
#>
	}
}<#+
	protected string DataFilename { get; set; }
	protected string Language { get; set; }
	protected string ClassName { get; set; }

	private string GetWriteable(object value, string valueType)
	{
		var enumerableValue = value as IEnumerable;
		if(valueType.EndsWith("[]") && enumerableValue != null) {
			var basicType = valueType.Substring(0, valueType.Length - 2);
			var writeableEnumerable = enumerableValue.Cast<string>().Select(x => GetWriteable(x, basicType));

			return string.Format("new {0} {{ {1} }}",
				valueType,
				string.Join(", ", writeableEnumerable));
		}
		else {
			switch (valueType) {
				case "char": return string.Format("'{0}'", value.ToString().Replace("'", @"\'"));
				case "int": 
				case "long": 
				case "double": 
				case "float": return string.Format("{0}", value);
				default: return string.Format("@\"{0}\"", value.ToString().Replace("\"", "\"\""));
			}
		}
	}

	private string GetDeclarationType(string valueType) {
		if(valueType.EndsWith("[]")) {
			var basicType = valueType.Substring(0, valueType.Length - 2);
			return string.Format("IEnumerable<{0}>", basicType);
		}

		return valueType;
	}

	private string GetSafeParameterValue(string value) {
		return value == null ? "NULL" : value;
	}
#>